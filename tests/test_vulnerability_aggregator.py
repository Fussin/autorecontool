import unittest
import json
import os
import shutil
import uuid
from datetime import datetime, timezone

# Adjust import path to access ch_modules from the tests directory
# This assumes 'tests' is at the same level as 'ch_modules' and 'cyberhunter3d'
# or that PYTHONPATH is set up accordingly (e.g. project root is in PYTHONPATH)
import sys
# Determine project root dynamically
current_dir = os.path.dirname(os.path.abspath(__file__)) # tests directory
project_root = os.path.dirname(current_dir) # Up to the directory containing 'ch_modules' and 'cyberhunter3d'
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from ch_modules.vulnerability_aggregator.main import aggregate_and_deduplicate_vulnerabilities
from ch_modules.vulnerability_aggregator.parsers import PARSER_MAPPING

class TestVulnerabilityAggregator(unittest.TestCase):
    def setUp(self):
        self.test_scan_id = f"test_agg_scan_{uuid.uuid4()}"
        self.base_dir = "temp_aggregator_test_space"
        self.scan_output_dir = os.path.join(self.base_dir, "dummy_target.com")
        os.makedirs(self.scan_output_dir, exist_ok=True)

        # Mock data
        self.now_iso = datetime.now(timezone.utc).isoformat()
        self.mock_xss_data = {
            "notes": "XSS test",
            "vulnerabilities": [
                {
                    "url": "http://dummy_target.com/search?q=vuln1", "param": "q",
                    "type": "Reflected XSS", "tool": "XSSScannerA",
                    "evidence": "Evidence from XSSScannerA for vuln1", "payload": "<script>alert(1)</script>"
                },
                { # Duplicate of above, different tool
                    "url": "http://dummy_target.com/search?q=vuln1", "param": "q",
                    "type": "Reflected XSS", "tool": "XSSScannerB",
                    "evidence": "Evidence from XSSScannerB for vuln1", "payload": "<script>alert(1)</script>"
                },
                {
                    "url": "http://dummy_target.com/profile#vuln2",
                    "type": "DOM XSS", "tool": "DOMScanner",
                    "evidence": "DOM XSS on profile page", "payload": "profile#<img src=x onerror=alert(2)>"
                }
            ]
        }
        self.mock_sqli_data = {
            "notes": "SQLi test",
            "vulnerabilities": [
                {
                    "url": "http://dummy_target.com/product?id=100", "parameter": "id",
                    "technique": "Error-based", "dbms": "MySQL",
                    "tool": "SQLMap", "evidence": "SQLMap error based output", "payload": "1' AND 1=1"
                },
                 { # Different type on same URL/param - should be distinct from above in current keying
                    "url": "http://dummy_target.com/product?id=100", "parameter": "id",
                    "technique": "Time-based Blind", "dbms": "MySQL",
                    "tool": "SQLNinja", "evidence": "SQLNinja time delay", "payload": "1' AND SLEEP(5)"
                },
                { # No param, different URL
                    "url": "http://dummy_target.com/login",
                    "type": "SQL Injection - Authentication Bypass", # More generic type from a conceptual tool
                    "tool": "AuthBypasser", "evidence": "Login successful with payload", "payload": "' OR '1'='1"
                }
            ]
        }
        self.mock_lfi_data = { # No vulns here to test empty file handling
            "notes": "LFI test - no findings",
            "vulnerabilities": []
        }

        # Write mock files
        with open(os.path.join(self.scan_output_dir, PARSER_MAPPING["xss"]["filename"]), 'w') as f:
            json.dump(self.mock_xss_data, f)
        with open(os.path.join(self.scan_output_dir, PARSER_MAPPING["sqli"]["filename"]), 'w') as f:
            json.dump(self.mock_sqli_data, f)
        with open(os.path.join(self.scan_output_dir, PARSER_MAPPING["lfi"]["filename"]), 'w') as f:
            json.dump(self.mock_lfi_data, f)

        # Create empty files for other parsers to ensure they are handled gracefully
        for key, p_info in PARSER_MAPPING.items():
            if key not in ["xss", "sqli", "lfi"]:
                 with open(os.path.join(self.scan_output_dir, p_info["filename"]), 'w') as f:
                    json.dump({"notes": f"{key} - no findings", "vulnerabilities": []}, f)


    def tearDown(self):
        if os.path.exists(self.base_dir):
            shutil.rmtree(self.base_dir)

    def test_aggregation_and_deduplication(self):
        aggregated_file_path = aggregate_and_deduplicate_vulnerabilities(self.scan_output_dir, self.test_scan_id)

        self.assertIsNotNone(aggregated_file_path, "Aggregator did not return a file path.")
        self.assertTrue(os.path.exists(aggregated_file_path), "Aggregated vulnerabilities file was not created.")

        with open(aggregated_file_path, 'r') as f:
            aggregated_data = json.load(f)

        # Expected unique vulnerabilities:
        # 1 merged XSS (from 2 XSSScannerA & XSSScannerB)
        # 1 DOM XSS
        # 1 SQLi Error-based
        # 1 SQLi Time-based (same URL/param but different technique considered distinct by parsers)
        # 1 SQLi Auth Bypass
        # Total = 5
        expected_unique_vuln_count = 5
        self.assertEqual(len(aggregated_data), expected_unique_vuln_count,
                         f"Expected {expected_unique_vuln_count} unique vulnerabilities, but got {len(aggregated_data)}")

        found_merged_xss = False
        found_dom_xss = False
        found_sqli_error = False
        found_sqli_time = False
        found_sqli_auth = False

        for vuln in aggregated_data:
            self.assertIn("id", vuln)
            self.assertIn("scan_id", vuln)
            self.assertEqual(vuln["scan_id"], self.test_scan_id)
            self.assertIn("vulnerability_type", vuln)
            self.assertIn("target_url", vuln)
            self.assertIn("severity", vuln)
            self.assertIn("confidence", vuln)
            self.assertIn("source_modules", vuln)
            self.assertTrue(isinstance(vuln["source_modules"], list))

            if "Reflected XSS" in vuln["vulnerability_type"] and vuln["target_url"] == "http://dummy_target.com/search?q=vuln1":
                found_merged_xss = True
                self.assertIn("XSSScannerA", vuln["source_modules"])
                self.assertIn("XSSScannerB", vuln["source_modules"])
                self.assertEqual(len(vuln["source_modules"]), 2)
                self.assertIn("Evidence from XSSScannerA", vuln["evidence"])
                self.assertIn("Evidence from XSSScannerB", vuln["evidence"])
                self.assertEqual(vuln["affected_component"], "Parameter: q")

            if "DOM XSS" in vuln["vulnerability_type"] and "dummy_target.com/profile#vuln2" in vuln["target_url"]:
                found_dom_xss = True
                self.assertIn("DOMScanner", vuln["source_modules"])

            if "SQL Injection (SQLi) - Error-based" in vuln["vulnerability_type"] and vuln["target_url"] == "http://dummy_target.com/product?id=100":
                found_sqli_error = True
                self.assertIn("SQLMap", vuln["source_modules"])
                self.assertEqual(vuln["affected_component"], "Parameter: id")

            if "SQL Injection (SQLi) - Time-based Blind" in vuln["vulnerability_type"] and vuln["target_url"] == "http://dummy_target.com/product?id=100":
                found_sqli_time = True
                self.assertIn("SQLNinja", vuln["source_modules"])
                self.assertEqual(vuln["affected_component"], "Parameter: id")

            if "SQL Injection - Authentication Bypass" in vuln["vulnerability_type"] and vuln["target_url"] == "http://dummy_target.com/login":
                found_sqli_auth = True
                self.assertIn("AuthBypasser", vuln["source_modules"])
                self.assertIsNone(vuln["affected_component"]) # Example of no specific param

        self.assertTrue(found_merged_xss, "Merged Reflected XSS vulnerability not found or not correctly processed.")
        self.assertTrue(found_dom_xss, "DOM XSS vulnerability not found.")
        self.assertTrue(found_sqli_error, "Error-based SQLi vulnerability not found.")
        self.assertTrue(found_sqli_time, "Time-based SQLi vulnerability not found.")
        self.assertTrue(found_sqli_auth, "Auth Bypass SQLi vulnerability not found.")

    def test_empty_inputs(self):
        # Test with a directory that has no vulnerability files or all are empty
        empty_scan_dir = os.path.join(self.base_dir, "empty_target.com")
        os.makedirs(empty_scan_dir, exist_ok=True)

        # Create only empty vulnerability files
        for key, p_info in PARSER_MAPPING.items():
            with open(os.path.join(empty_scan_dir, p_info["filename"]), 'w') as f:
                json.dump({"notes": f"{key} - no findings", "vulnerabilities": []}, f)

        aggregated_file_path = aggregate_and_deduplicate_vulnerabilities(empty_scan_dir, f"empty_scan_{uuid.uuid4()}")

        self.assertIsNotNone(aggregated_file_path)
        self.assertTrue(os.path.exists(aggregated_file_path))
        with open(aggregated_file_path, 'r') as f:
            aggregated_data = json.load(f)
        self.assertEqual(len(aggregated_data), 0, "Aggregated file should be empty when all inputs are empty.")

    def test_missing_some_files(self):
        # Remove one of the mock files to test robustness
        os.remove(os.path.join(self.scan_output_dir, PARSER_MAPPING["sqli"]["filename"]))

        aggregated_file_path = aggregate_and_deduplicate_vulnerabilities(self.scan_output_dir, f"missing_file_scan_{uuid.uuid4()}")
        self.assertIsNotNone(aggregated_file_path)
        self.assertTrue(os.path.exists(aggregated_file_path))
        with open(aggregated_file_path, 'r') as f:
            aggregated_data = json.load(f)

        # Expected: 1 merged XSS, 1 DOM XSS = 2 total
        self.assertEqual(len(aggregated_data), 2,
                         "Expected 2 vulnerabilities when SQLi file is missing.")

        # Check if any XSS types are present
        xss_present = any(v["vulnerability_type"].startswith("Cross-Site Scripting") or "XSS" in v["vulnerability_type"] for v in aggregated_data)
        self.assertTrue(xss_present, "No XSS related vulnerabilities found when SQLi file was missing.")

        # Check if any SQLi types are present (should not be)
        sqli_present = any(v["vulnerability_type"].startswith("SQL Injection") for v in aggregated_data)
        self.assertFalse(sqli_present, "SQLi vulnerabilities found even when SQLi file was missing.")


if __name__ == '__main__':
    unittest.main()
