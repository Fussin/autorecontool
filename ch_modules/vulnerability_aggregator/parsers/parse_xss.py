import json
import uuid
from datetime import datetime, timezone

def parse_xss_vulnerabilities(json_file_path, scan_id):
    """
    Parses XSS vulnerability data from a JSON file and transforms it
    into the unified vulnerability schema.

    Args:
        json_file_path (str): Path to the XSS module's JSON output file.
        scan_id (str): The ID of the scan job.

    Returns:
        list: A list of vulnerability objects adhering to the unified schema.
              Returns an empty list if the file doesn't exist, is empty,
              or contains no actual vulnerabilities.
    """
    unified_vulnerabilities = []
    try:
        with open(json_file_path, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        # print(f"Info: XSS results file not found: {json_file_path}")
        return unified_vulnerabilities
    except json.JSONDecodeError:
        # print(f"Error: Could not decode XSS results file: {json_file_path}")
        return unified_vulnerabilities

    # Current placeholder XSS modules output a structure like:
    # {
    #   "notes": "...",
    #   "vulnerabilities": [
    #     {
    #       "url": "http://example.com/search?q=<script>alert(1)</script>",
    #       "param": "q",
    #       "type": "Reflected XSS",
    #       "tool": "Dalfox (Conceptual)"
    #     }
    #   ]
    # }
    # Or, if no vulns: { "notes": "XSS scanning skipped...", "vulnerabilities": [] }

    raw_vulnerabilities = data.get("vulnerabilities", [])
    if not raw_vulnerabilities:
        # print(f"Info: No XSS vulnerabilities found in {json_file_path}")
        return unified_vulnerabilities

    for vuln in raw_vulnerabilities:
        # This is a basic mapping. Real XSS tools would provide more details.
        # We'll make some assumptions for severity/confidence for placeholders.

        vuln_type_detail = vuln.get("type", "Cross-Site Scripting (XSS) - Generic")
        if "Reflected" in vuln_type_detail:
            severity = "Medium"
            confidence = "Medium" # Placeholder tools might not be highly confident
        elif "Stored" in vuln_type_detail:
            severity = "High"
            confidence = "Medium"
        elif "DOM" in vuln_type_detail:
            severity = "Medium"
            confidence = "Low" # DOM XSS often needs more manual validation
        else:
            severity = "Medium"
            confidence = "Low"

        description = vuln.get("description", f"Potential {vuln_type_detail} identified by {vuln.get('tool', 'XSS Hunter')}.")
        if vuln.get("param"):
            description += f" Affected parameter: {vuln.get('param')}."

        now_utc = datetime.now(timezone.utc).isoformat()

        unified_vuln = {
            "id": str(uuid.uuid4()),
            "vulnerability_type": vuln_type_detail,
            "description": description,
            "target_url": vuln.get("url", "N/A"),
            "affected_component": f"Parameter: {vuln.get('param')}" if vuln.get('param') else None,
            "payload": vuln.get("payload", None), # Placeholder might not have specific payloads
            "evidence": vuln.get("evidence", f"Finding reported by {vuln.get('tool', 'XSS Hunter')}."),
            "severity": severity,
            "confidence": confidence,
            "source_modules": [vuln.get("tool", "XSS Hunter")], # Later, aggregator might merge this
            "first_seen_timestamp": now_utc,
            "last_seen_timestamp": now_utc,
            "status": "New",
            "cwe_ids": [79], # Common CWE for XSS
            "cvss_vector": None, # Placeholder, would need calculation
            "cvss_score": None,  # Placeholder
            "remediation_advice": "Sanitize user inputs and use output encoding. Implement Content Security Policy (CSP).",
            "tags": ["XSS", vuln.get("tool", "XSS Hunter").replace(" ", "_")],
            "scan_id": scan_id
        }
        unified_vulnerabilities.append(unified_vuln)

    return unified_vulnerabilities

if __name__ == '__main__':
    # Example usage (for testing the parser directly)
    # Create a dummy xss_vulnerabilities.json
    dummy_data = {
        "notes": "Conceptual XSS scan completed for example.com.",
        "vulnerabilities": [
            {
                "url": "http://example.com/search?q=<script>alert(1)</script>",
                "param": "q",
                "type": "Reflected XSS",
                "tool": "Dalfox (Conceptual)",
                "payload": "<script>alert(1)</script>",
                "evidence": "Conceptual detection based on reflection."
            },
            {
                "url": "http://example.com/profile#<img src=x onerror=alert(2)>",
                "type": "DOM XSS (Conceptual)",
                "tool": "Headless Browser (Conceptual)",
                "payload": "<img src=x onerror=alert(2)>",
                "evidence": "Conceptual detection in DOM."
            }
        ]
    }
    dummy_file = "dummy_xss_vulnerabilities.json"
    with open(dummy_file, 'w') as f:
        json.dump(dummy_data, f, indent=2)

    parsed_vulns = parse_xss_vulnerabilities(dummy_file, "test_scan_123")
    if parsed_vulns:
        print(f"Successfully parsed {len(parsed_vulns)} XSS vulnerabilities:")
        for v in parsed_vulns:
            print(json.dumps(v, indent=2))
    else:
        print("No XSS vulnerabilities parsed or file not found.")

    # Test with non-existent file
    print("\nTesting with non-existent file:")
    parsed_vulns_non_existent = parse_xss_vulnerabilities("non_existent.json", "test_scan_456")
    if not parsed_vulns_non_existent:
        print("Correctly handled non-existent file (returned empty list).")

    # Test with empty vulnerabilities list
    dummy_empty_data = {"notes": "No vulns found.", "vulnerabilities": []}
    dummy_empty_file = "dummy_empty_xss_vulnerabilities.json"
    with open(dummy_empty_file, 'w') as f:
        json.dump(dummy_empty_data, f, indent=2)

    print("\nTesting with empty vulnerabilities list:")
    parsed_vulns_empty = parse_xss_vulnerabilities(dummy_empty_file, "test_scan_789")
    if not parsed_vulns_empty:
        print("Correctly handled empty vulnerabilities list (returned empty list).")

    # Clean up dummy files
    import os
    os.remove(dummy_file)
    os.remove(dummy_empty_file)
