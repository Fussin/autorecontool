import json
import uuid
from datetime import datetime, timezone

def parse_sqli_vulnerabilities(json_file_path, scan_id):
    """
    Parses SQL Injection vulnerability data from a JSON file (currently SQLMap's
    placeholder output) and transforms it into the unified vulnerability schema.

    Args:
        json_file_path (str): Path to the SQLi module's JSON output file.
        scan_id (str): The ID of the scan job.

    Returns:
        list: A list of vulnerability objects adhering to the unified schema.
              Returns an empty list if the file doesn't exist, is empty,
              or contains no actual vulnerabilities.
    """
    unified_vulnerabilities = []
    try:
        with open(json_file_path, 'r') as f:
            data = json.load(f)
    except FileNotFoundError:
        # print(f"Info: SQLi results file not found: {json_file_path}")
        return unified_vulnerabilities
    except json.JSONDecodeError:
        # print(f"Error: Could not decode SQLi results file: {json_file_path}")
        return unified_vulnerabilities

    # Current SQLi module (with actual SQLMap) outputs a structure like:
    # {
    #   "notes": "SQLMap scan results for target_url",
    #   "vulnerabilities": [
    #     {
    #       "url": "http://testphp.vulnweb.com/artists.php?artist=1",
    #       "parameter": "artist",
    #       "dbms": "MySQL",
    #       "technique": "Error-based",
    #       "payload": "1 AND (SELECT ...)", // Example
    #       "sqlmap_output_dir": "/app/cyberhunter3d/instance/scan_outputs/testphp.vulnweb.com/sqlmap_output/testphp.vulnweb.com_artists.php_artist_1"
    #     }
    #   ]
    # }
    # Or, if no vulns: { "notes": "SQLMap scan finished. No vulnerabilities found...", "vulnerabilities": [] }
    # Or, if conceptual: { "notes": "Conceptual SQLi scan for example.com", "vulnerabilities": [{"type": "Conceptual SQLi", "url": "...", "tool": "SQLMap (Conceptual)"}]}


    raw_vulnerabilities = data.get("vulnerabilities", [])
    if not raw_vulnerabilities:
        # print(f"Info: No SQLi vulnerabilities found in {json_file_path}")
        return unified_vulnerabilities

    for vuln in raw_vulnerabilities:
        # Revised type determination logic
        vuln_type_from_input = vuln.get("type") # Original 'type' field from the JSON, e.g., "Conceptual SQLi", "SQL Injection - Authentication Bypass"
        technique_from_input = vuln.get("technique") # Specific technique, e.g., "Error-based SQL Injection", "Time-based Blind"
        dbms = vuln.get("dbms")

        final_vuln_type = "SQL Injection (SQLi)" # Default base name

        if technique_from_input:
            # If a specific 'technique' is given (often from SQLMap detailed output), use it.
            # Ensure it doesn't redundantly include "SQL Injection" if technique_from_input is already full.
            if "sql injection" in technique_from_input.lower():
                 final_vuln_type = technique_from_input # e.g. "Error-based SQL Injection"
            else:
                 final_vuln_type = f"SQL Injection (SQLi) - {technique_from_input}"
        elif vuln_type_from_input:
            # If no 'technique', but 'type' field exists and is descriptive
            if "sql injection" in vuln_type_from_input.lower():
                final_vuln_type = vuln_type_from_input # e.g. "SQL Injection - Authentication Bypass"
            elif vuln_type_from_input == "Conceptual SQLi": # Handle specific known placeholder type
                final_vuln_type = "SQL Injection (SQLi) - Conceptual"
            else: # Fallback if 'type' is some other short string, append it
                final_vuln_type = f"SQL Injection (SQLi) - {vuln_type_from_input}"
        # If neither technique_from_input nor vuln_type_from_input is useful, it remains "SQL Injection (SQLi)"

        if dbms:
            final_vuln_type += f" (DBMS: {dbms})"

        # Use 'final_vuln_type' for description and unified object
        description = f"Potential {final_vuln_type} identified at {vuln.get('url', 'N/A')}."
        if vuln.get("parameter"):
            description += f" Affected parameter: {vuln.get('parameter')}."
        if vuln.get("sqlmap_output_dir"):
            description += f" SQLMap session data available at: {vuln.get('sqlmap_output_dir')}."

        severity = "High" # Default
        if "Error-based" in final_vuln_type or "Union-based" in final_vuln_type or \
           "Time-based" in final_vuln_type or "Blind" in final_vuln_type or \
           "Authentication Bypass" in final_vuln_type:
            severity = "Critical"

        confidence = "Medium"
        if vuln.get("sqlmap_output_dir"):
            confidence = "High"
        elif "Conceptual" in final_vuln_type or not (technique_from_input or vuln.get("sqlmap_output_dir")):
            confidence = "Low"


        now_utc = datetime.now(timezone.utc).isoformat()
        source_tool = "SQLMap" if vuln.get("sqlmap_output_dir") else vuln.get("tool", "SQLi Scanner")


        unified_vuln = {
            "id": str(uuid.uuid4()),
            "vulnerability_type": final_vuln_type,
            "description": description,
            "target_url": vuln.get("url", "N/A"),
            "affected_component": f"Parameter: {vuln.get('parameter')}" if vuln.get('parameter') else None,
            "payload": vuln.get("payload", None), # SQLMap might log this in its files
            "evidence": f"Finding reported by {source_tool}. Details in SQLMap logs if available: {vuln.get('sqlmap_output_dir', 'N/A')}",
            "severity": severity,
            "confidence": confidence,
            "source_modules": [source_tool],
            "first_seen_timestamp": now_utc,
            "last_seen_timestamp": now_utc,
            "status": "New",
            "cwe_ids": [89], # Common CWE for SQLi
            "cvss_vector": None, # Placeholder
            "cvss_score": None,  # Placeholder
            "remediation_advice": "Use parameterized queries (prepared statements) to prevent SQL injection. Validate and sanitize all user inputs. Apply least privilege principle for database access.",
            "tags": ["SQLi", source_tool.replace(" ", "_")],
            "scan_id": scan_id
        }
        unified_vulnerabilities.append(unified_vuln)

    return unified_vulnerabilities

if __name__ == '__main__':
    # Example usage
    dummy_data_sqlmap = {
        "notes": "SQLMap scan results for target_url",
        "vulnerabilities": [
            {
                "url": "http://testphp.vulnweb.com/artists.php?artist=1",
                "parameter": "artist",
                "dbms": "MySQL",
                "technique": "Error-based SQL Injection",
                "payload": "1 AND (SELECT ...)",
                "sqlmap_output_dir": "/app/cyberhunter3d/instance/scan_outputs/testphp.vulnweb.com/sqlmap_output/testphp.vulnweb.com_artists.php_artist_1"
            }
        ]
    }
    dummy_file_sqlmap = "dummy_sqli_vulnerabilities_sqlmap.json"
    with open(dummy_file_sqlmap, 'w') as f:
        json.dump(dummy_data_sqlmap, f, indent=2)

    parsed_vulns_sqlmap = parse_sqli_vulnerabilities(dummy_file_sqlmap, "test_scan_sqlmap_001")
    if parsed_vulns_sqlmap:
        print(f"Successfully parsed {len(parsed_vulns_sqlmap)} SQLi vulnerabilities (from SQLMap-like output):")
        for v in parsed_vulns_sqlmap:
            print(json.dumps(v, indent=2))
    else:
        print("No SQLi vulnerabilities parsed or file not found.")

    dummy_data_conceptual = {
        "notes": "Conceptual SQLi scan for example.com",
        "vulnerabilities": [
            {
                "type": "Conceptual SQLi",
                "url": "http://example.com/product?id=1'",
                "tool": "SQLMap (Conceptual)"
            }
        ]
    }
    dummy_file_conceptual = "dummy_sqli_vulnerabilities_conceptual.json"
    with open(dummy_file_conceptual, 'w') as f:
        json.dump(dummy_data_conceptual, f, indent=2)

    parsed_vulns_conceptual = parse_sqli_vulnerabilities(dummy_file_conceptual, "test_scan_conceptual_002")
    if parsed_vulns_conceptual:
        print(f"\nSuccessfully parsed {len(parsed_vulns_conceptual)} SQLi vulnerabilities (from conceptual output):")
        for v in parsed_vulns_conceptual:
            print(json.dumps(v, indent=2))
    else:
        print("No SQLi vulnerabilities parsed or file not found.")

    # Clean up dummy files
    import os
    os.remove(dummy_file_sqlmap)
    os.remove(dummy_file_conceptual)
